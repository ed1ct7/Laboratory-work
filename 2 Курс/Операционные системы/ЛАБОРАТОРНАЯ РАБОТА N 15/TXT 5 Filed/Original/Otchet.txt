МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РФ
федеральное государственное автономное образовательное учреждение высшего образования
«Санкт–Петербургский государственный университет
аэрокосмического приборостроения»
ФАКУЛЬТЕТ СРЕДНЕГО ПРОФЕССИОНАЛЬНОГО ОБРАЗОВАНИЯ

ОТЧЕТ 
ЗАЩИЩЕН С ОЦЕНКОЙ
РУКОВОДИТЕЛЬ   _____________________________

преподаватель		
		
У.С Опалева
должность, уч. степень, звание		подпись, дата		инициалы, фамилия





ОТЧЕТ ПО ЛАБОРАТОРНЫМ РАБОТАМ

по дисциплине Операционные системы и среды







РАБОТУ ВЫПОЛНИЛ
СТУДЕНТ ГР. №	С326				Э.С. Тигранян
			подпись, дата		инициалы, фамилия









Санкт-Петербург 2024 
Contents
ЛАБОРАТОРНАЯ РАБОТА №1. Работа в командной строке ОС WINDOWS.	3
ЛАБОРАТОРНАЯ РАБОТА №2,3.  Планирование заданий с учетом требований к памяти и внешним устройствам	19
ЛАБОРАТОРНАЯ РАБОТА №4,5. Ознакомление с функциональными возможностями Системного Монитора. Управление виртуальной памятью, настройка файла подкачки	28
ЛАБОРАТОРНАЯ РАБОТА №6,7. Использование встроенных команд ОС для работы с файловой системой.	41
ЛАБОРАТОРНАЯ РАБОТА №8,9. Команды ФС	52
ЛАБОРАТОРНАЯ РАБОТА №10,11. Пакетные файлы в ОС windows	62
Запуск:	62
ЛАБОРАТОРНАЯ РАБОТА №12,13. WindowsPowerShell	76
ЛАБОРАТОРНАЯ РАБОТА №14. Работа со встроенной утилитой ОС WINDOWS «Диспетчер задач».	97

 
ЛАБОРАТОРНАЯ РАБОТА №1. Работа в командной строке ОС WINDOWS.
Цель работы: выполнить ввод сетевых и системных команд в терминальном режиме. 
Задание к лабораторной работе.
1.	Того, что бы можно было копировать содержимое окна, необходимо правой кнопкой мыши щелкнуть по заголовку окна и в появившемся новом окне выбрать “Свойства”. Затем необходимо поставить галку “Выделение мышью”.
2.	Создать файл отчёта, в котором будут отображены результаты выполнения лабораторной работы (заполнять параллельно с выполнением работы). Файл сохранить в своей папке на сетевом диске V:.
3.	Последовательно проработать следующие команды:
ipconfig – обратить внимание на IP-адрес компьютера, он может быть использован в качестве параметра для ввода других сетевых команд.
getmac – в какой системе счисления выдаётся физический адрес?
arp –a - вывести остальные параметры команды arp.
ping –a - успешно ли проведено тестирование, сколько отправлено пакетов?
tracert - в качестве конечного узла ввести IP-адрес своего компьютера.
pathping - в качестве конечного узла ввести IP-адрес своего компьютера.
netstat –e - меняется ли статистика интерфейса при повторном вводе команды?
netstat –r - попробуйте выполнить команду ping –a с адресами, отличными IP-адрес своего компьютера, получен ли успешный результат?
route print – после занесения данных в отчёт выполните очистку командного окна.
calc – в инженерном режиме калькулятора (меню Вид) выполните перевод значения физического адреса (команда getmac в командной строке) в двоичное представление.
taskkill/? – выпишите назначение команды taskkill, по приведённому в справке примеру выполните принудительное завершение работы с калькулятором из командной строки.
notepad – комбинацией CTRL+S вызовите окно сохранения документа, сохраните текстовый документ в своей папке сетевом диске V:.
osk – посредством экранной клавиатуры наберите в текстовом файле ФИО.
charmap – в открытый текстовый документ с набранными данными ФИО скопируйте из таблицы символов значок авторских прав, сохраните документ, затем выполните принудительное завершение (командой taskkill с соответствующими параметрами) приложений «Блокнот», «Экранная клавиатура» и «Таблица символов» из командной строки.
control – в открывшейся панели управления выберите объект «Администрирование» – «Конфигурация системы» – «Сервис» – «Сведения о системе» – «Запуск», выпишите основные технические характеристики вашего компьютера.
explorer – перейти в свою папку, отображаются ли по умолчанию расширения файлов?
control folders – на закладке «Вид» в списке найти и отключить опцию «Скрывать расширения для зарегистрированных типов файлов, проверить результат в своей папке.
devmgmt.msc – из меню «Вид» выбрать пункт «Показать скрытые устройства», после отображения результата снять эту опцию, затем выбрать пункт «Ресурсы по типу». Какие группы показаны в окне «Диспетчера устройств»?
taskmgr – перейти на закладку «Процессы».
start excel.exe – найти соответствующий процесс в списке «Диспетчера задач» – Завершить процесс.
chcp – попробуйте сменить кодировку на 1251, наберите команду help и сравните результат? Восстановите прежнюю кодировку (по умолчанию 866).
Специальной командой выполните выход из командной строки.
Контрольные вопросы:
Для чего нужна командная строка WINDOWS? Как её вызвать, а затем закрыть?
Каким образом осуществляется ввод команд, «проход» по истории, очистка экрана?
Какие группы команд вы знаете? Приведите примеры команд из каждой группы.
Выполнение:
Команда ipconfig - отображение полной информации всех сетевых адаптеров
 
Рисунок 1 – результат выполнения команды ipconfig
 
Команда arp -a – вывод arp таблицу
 
Рисунок 2 – 
Результат выводится в шестнадцатеричной системе исчисления.
Команда getmac – получение mac адресов сетевых карт.
 
Рисунок 3 – результат выполнения команды 
Команда arp – получение всех аргументов arp таблиц.
 
Рисунок 4 – результат выполнения команды arp

Команда ping -a – отправка пакетов по адресов.
 
Рисунок 5 – результат
Команда tracert – трасировка (отслеживание) маршрута.
 
Рисунок 6 – результат выполнение команды tracert
Команда pathping – трассировка маршрута с потоками.
 
Рисунок 7 -результат выполнения команды

Команда netstat -e – статистика интерфейсов
 
Рисунок 8 – Результат выполнения команды netstat -e
Команда netstat -r – отображение содержимого таблицы маршрутов
 
Рисунок 9 – Результат выполнения команды
 
Команда ping -a - отправка пакетов по локальному адресу.
 
Рисунок 10 -Результат выполнение команды ping -a с айпи адресом другого компьютера
Команда route print - отображение содержимого таблицы маршрутов
 
Рисунок 11 – Результат выполнение команды
Команда calc – запускает калькулятор
 
Рисунок 12 – результат выполнения команды
Использование калькулятора
 
Рисунок 13 – Результат выполнение команды
Команда taskkill – закрытие процесса
 
Рисунок 14 – Результат выполнение команды
Использование команды
 
Рисунок 15 - Результат выполнение команды
Команда notepad – запуск блокнота
 
Рисунок 16 - Результат выполнение команды
Команда osk – запуск виртуальной клавиатуры
 
Рисунок 17 - Результат выполнение команды
Команда charmap – запуск символов UTF
 
Рисунок 18 - Результат выполнение команды
Закрытие приложений
 
Рисунок 19 - Результат выполнение команд
Команда control – запуск Панели управления
 
Рисунок 20 - Результат выполнение задачи
 
Рисунок 21 – Результат выполнение команды control
Изменение параметров проводника
 
Рисунок 22 - Результат выполнение команды control folders
 
Результат
 
Рисунок 23 - Результат выполнение команды
Команда devmgmt.msc – запуск диспетчера устройств
 
 Рисунок 24 - Результат выполнение команды
Команда start excel.exe – запуск excel
Команда taskmgr – запуск диспетчере задач
 
Рисунок 25 - Результат выполнение команды
Команда chcp – вывод и смена кодировки
 
Рисунок 26  Результат выполнение команды
Контрольные вопросы:
1.	Для чего нужна командная строка WINDOWS? Как её вызвать, а затем закрыть?
Командная строка ОС WINDOWS позволяет осуществлять управление системой посредством последовательного ввода команд в текстовом режиме алфавитно-цифрового терминального окна.
Консоль можно вызвать следующими способами:
1 способ
Пуск — > Выполнить (напротив “все программы”) — > в появившемся окне набрать cmd (command для 98/МЕ).
2 способ
Комбинация клавиш — start+r  (кнопки start обычно обозначаются значком Windows (флажок) и располагаются по обе стороны от пробела около кнопки Alt). Затем вводим в появившемся окне буквы – cmd (command для 98/МЕ).
3 способ
Пуск — > Все программы — > Стандартные — > Командная строка (Command Promt).
4 способ
Попасть в командный режим можно также по этому пути. C:\WINDOWS\system32\cmd.exe или C:\WINDOWS\system32\command.com
2.	Каким образом осуществляется ввод команд, «проход» по истории, очистка экрана?
Запись в консоль.
Очистка cls.
Чтобы выбрать ранее введённую команду можно «прокручивать» историю команд клавишами управления курсором ↑↓.
3.	Какие группы команд вы знаете? Приведите примеры команд из каждой группы.
•	Сетевые комманды
ipconfig /all - отображение полной информации всех сетевых адаптеров. getmac - получить MAC-адреса сетевых карт. arp -a - просмотр arp таблицы. ping [конечный_узел] [ключ] - простучать сетевой адрес.
•	Системные команды
shutdown /r - перезагрузка компьютера.
shutdown /s — выключение компьютера.
•	Вызов системных утилит
chkdsk — утилита проверка дисков.
control — запускает “Панель управления”.
 
ЛАБОРАТОРНАЯ РАБОТА №2,3.  Планирование заданий с учетом требований к памяти и внешним устройствам
Цель работы: изучение и исследование некоторых алгоритмов и способов планирования заданий (с учетом требований к памяти и внешним устройствам) в мультипрограммной вычислительной системе.
Исходные данные:
 
Таблица длинных потоков
 
Таблица коротких потоков
 
Таблица длинных пакетов
 
Таблица коротких пакетов
Количество
ОП	LIFO	PRT
	Короткие	Длинные	Короткие	Длинные
	пакет	поток	пакет	поток	пакет	поток	пакет	поток
8	1,81	1,77	1,63	1,6	2,55	2,09	1,63	1,6
12	1,94	1,76	1,45	1,58	2,13	1,77	1,57	1,58
16	1,62	1,76	1,45	1,58	2,13	1,77	1,57	1,58
Таблица результатов средневзвешенного времени выполнения заданий
Количество
ОП	LIFO	PRT
	Короткие	Длинные	Короткие	Длинные
	пакет	поток	пакет	поток	пакет	поток	пакет	поток
8	3	3	2	2	3	3	2	2
12	3	4	2	2	4	4	2	2
16	3	4	2	2	4	4	2	2
Таблица максимальных значений коэффициентов мультипрограммирования
 
Графики зависимости средневзвешенного времени выполнения пакета (потока) работ от количества ОП.
    
 
Графики зависимости коэффициента мультипрограммирования от количества ОП.
    
 
Сравнительные анализ:
Средневзвешенное время выполнение чаще всего падает с возрастанием оперативной памяти. prt является не эффективной дисциплиной планирования при условиях не эффективного пользования.
Коэффициент мультипрограммирование растёт с возрастанием оперативной памяти.
Контрольные вопросы:
1.	Определите понятия: задание, шаг задания, задача, процесс.
•	Задание представляет собой описание комплекса работ, которые пользователь хочет выполнить на ЭВМ. 
•	Этот комплекс может быть представлен в виде последовательности некоторых частных работ, описываемых с помощью шагов задания. 
•	Из шагов задания формируются задачи. Для выполнения задач система создает процессы. 
•	Объектами работы планировщика заданий являются задания, а планировщик задач управляет процессами.
2.	Каковы функции планировщика заданий?
Планировщик процессов должен решить, какому из созданных процессов предоставить процессор, в какой момент и на какое время.
Планировщик заданий обеспечивает определенную дисциплину выбора заданий на обработку. Для принятия такого решения могут учитываться такие характеристики заданий, как приоритет, необходимые ресурсы и т.п. Планировщик заданий не только выделяет необходимые ресурсы для поступающего на обработку задания, но и освобождает ресурсы после выполнения задания.
3.	Приведите примеры дисциплин обслуживания.
Линейная дисциплина обслуживания FIFO (First In – First Out). Из очереди заявок на обслуживание выбирается заявка, поступившая в очередь первой.
Линейная дисциплина обслуживания LIFO (Last In – First Out). Из очереди заявок на обслуживание выбирается заявка, поступившая в очередь последней.
Дисциплина обслуживания с фиксированным приоритетом SJF (Short Job First). Из очереди заявок на обслуживание выбирается заявка с минимальным временем обслуживания.
Дисциплина обслуживания с фиксированным приоритетом PRT (PRioriTy). Из очереди заявок на обслуживание выбирается заявка с максимальным приоритетом.
4.	Приведите классификацию дисциплин обслуживания.
•	Приоритетные
•	Бесприоритетные
5.	Какие существуют критерии планирования?
•	Справедливость – гарантировать каждому заданию или процессу определенную часть времени использования процессора в компьютерной системе, стараясь не допустить возникновения ситуации, когда процесс одного пользователя постоянно занимает процессор, в то время как процесс другого пользователя фактически не начинал выполняться.
•	Эффективность – постараться занять процессор на все 100% рабочего времени, не позволяя ему простаивать в ожидании процессов, готовых к исполнению. В реальных вычислительных системах загрузка процессора колеблется от 40 до 90%.
•	Сокращение полного времени выполнения ( turnaround time ) – обеспечить минимальное время между стартом процесса или постановкой задания в очередь для загрузки и его завершением.
•	Сокращение времени ожидания ( waiting time ) – сократить время, которое проводят процессы в состоянии готовность и задания в очереди для загрузки.
•	Сокращение времени отклика ( response time ) – минимизировать время, которое требуется процессу в интерактивных системах для ответа на запрос пользователя.
6.	Какие существуют оценки эффективности планирования?
t = tЗ – tП, где
t – время обращения задания,
tЗ – время завершения задания,
tП – время поступления задания.
W = (tЗ – tП) / T, где
W – взвешенное время обращения,
T – действительное время выполнения задания.
WСР – средневзвешенное время обращения.
 
ЛАБОРАТОРНАЯ РАБОТА №4,5. Ознакомление с функциональными возможностями Системного Монитора. Управление виртуальной памятью, настройка файла подкачки 
Цель работы: изучение принципов и режимов работы встроенного Системного Монитора и исследование параметров основной и виртуальной памяти ПК.
Первая часть лабораторной работы
 
Рисунок 1 – интерфейс системного монитора в win11
 
Рисунок 2 – скрытие дерева
 
Рисунок 3 – результат запуска photoshop
 
Рисунок 4 – отчёт  по текущим счётчикам
 
Рисунок 5 – стили для отображения линий графика
 
Рисунок 6 – отображение сетки
 
Рисунок 7 – результат копирования в буфер обмена
 
Рисунок 8 – активность диска при сохранения файла
 
Рисунок 9 – Результат открытия файла
 
Рисунок 10 – Динамика
При загрузки памяти на 100 начинает загружаться файл подкачки.
При резком снижения обмена страниц снижается и загруженности процессора.
Функции системного монитора:
 
 
 
   
 
Наименование счётчика	Определение (описание)
% использования выделенной памяти	процент использования памяти в момент времени
Обмен страниц/c	количество страниц обмениваемых в секунду
% загруженности процессора	процент загруженности процессора в момент времени
% использования файла подкачки	процент использования файла подкачки в момент времени
Таблица 3. Перечень счётчиков с определениями
Номер объекта	Наименование объекта	Полный перечень счётчиков
1	Процессор	% времени С1,
% времени С2,
% времени С3,
% времени DPC,
% времени прерываний,
% загруженности процессора,
%работы в пользовательском режим
%работы в привилегированном режим
C1 переходов/сек
C2 переходов/сек
C3 переходов/сек
Поставлено в очередь DPC/сек
Прерываний/с
Процент времени бездействия
Скорость PDC
2	Файл подкачки	% использования
% использования пик
3	Экземпляр WinNAT	Доступные TCP-порты
Доступные UDP-порты
Используемые TCP-порты
Используемые UDP-порты
4	Фильтр получения PacketDirect	Сопоставлено байтов
Сопоставлено байтов/с
Сопоставлено пакетов
Сопоставлено пакетов/с
5	Объекты	Потоки
Счетчик мьютексов
Счетчик процессор
Счетчик секций
Счетчик семафоров
Счетчик событий
Таблица 2. Перечень объектов и счётчиков

Вторая часть лабораторной работы
Заполнить таблицу следующим образом: виртуальная память в 2 раза больше ОЗУ для серверных и равна ОЗУ для локальных ОС; количество занятой виртуальной памяти рассчитывается по схеме – (50 + №студента по списку)% от размера выделенной виртуальной памяти; начальный размер файла подкачки 1/3 от ОЗУ; максимальный размер файла подкачки в 3 раза больше ОЗУ в том случае, если она не более 8Гб и в 1,5 раза меньше ОЗУ в остальных случаях; количество выгружаемых в виртуальную память страниц рассчитывается исходя из разности между занятой виртуальной памятью и объёмом ОЗУ, а также объёмом одной страницы – 4096 байт. 

ОС	ОЗУ (Гб)	Виртуал. память (Мб)	Занято (Мб)	Подкачка нач. (Мб)	Подкачка макс. (Мб)	Кол-во страниц
Windows XP	4	4096	2949,12	1365	12288	0
Windows Server 2000 	8	16384	11796,48	2731	24576	922806
Windows Server 2003	32	65536	47185,92	10923	98304	3691224
Windows Server 2008	64	131072	94371,84	21845	196608	7382448
Используемые формулы:
 
 
   


Контрольные вопросы:
7.	Определите понятия: память, физический диск, логический диск, кэш 1 и 2 уровня, виртуальная память, файл подкачки.
Тип памяти, в котором во время работы компьютера хранится выполняемый машинный код и данные, которые в этот момент обрабатывает процессор.
физический диск - это реально подключенный диск к системе (как внутреннее или внешнее устройство).
логический диск - это виртуальное устройство, которое обеспечивает область полезной емкости на одном или нескольких физических дисководах в компьютерной системе 
Кэш-память первого уровня (L1) — это самая маленькая, но и самая быстрая область кэш-памяти. Её объём не превышает пару десятков килобайт. Работает L1 без каких-либо задержек. В нём содержатся данные, которые чаще всего используются процессором. 
Кэш-память второго уровня (L2) чуть медленнее кэш-памяти L1, но и объём её в современных процессорах измеряется уже в мегабайтах. Служит она для временного хранения важных данных, вероятность запроса которых ниже, чем у данных, находящихся в L1 кэше.
Виртуальная память — это метод управления памятью компьютера, позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере.
Файл подкачки — это специальный файл на жёстком диске или твердотельном накопителе компьютера, в который записываются данные оперативной памяти, когда её начинает не хватать для нормальной работы операционной системы.
Каковы основные схемы управления памятью?
•	Сегментированная
•	Страничная
•	Сегментно-страничная
•	Виртуальная
•	Физическая
8.	Опишите механизм работы и настройки файла подкачки.
Чтобы немного разгрузить ресурсы оперативной памяти, на жестком диске создается специальный файл, в котором ОС также хранит текущие данные.
Файл подкачки автоматически создается ОС в корневой папке того диска, где расположена сама система.
Размер файла подкачки и его расположение можно изменять. Для этого нужно на Панели управления компьютера выбрать компоненту Система, затем на вкладке Дополнительно перейти в раздел Быстродействие, вызвать Параметры, в окне Параметры быстродействия вкладке Дополнительно в области Виртуальная память нажать кнопку Изменить. Откроется окно Виртуальная память
9.	Приведите перечень основных объектов Системного Монитора.
•	Battery Status
•	BitLocker
•	IPV4
•	Кеш
•	Логический диск
•	Процессор
•	Память
•	Физический диск
•	Файл подкачки
•	Телефония
ЛАБОРАТОРНАЯ РАБОТА №6,7. Использование встроенных команд ОС для работы с файловой системой.
Цель работы: выполнить операции с файлами и каталогами в терминальном режиме.
Задание к лабораторной работе.
1.	Получить полный список команд DOS (команда – help).
 
2.	Скопировать в отчёт все команды для работы с файловой системой (включить опцию «Выделение мышью», выделить нужный текстовый фрагмент, нажать Enter, выполнить вставку из буфера обмена).
ASSOC          Вывод либо изменение сопоставлений по расширениям имен файлов.
ATTRIB         Отображение и изменение атрибутов файлов.
CACLS          Отображение и редактирование списков управления доступом (ACL)
               к файлам.
CALL           Вызов одного пакетного файла из другого.
CD             Вывод имени либо смена текущей папки.
CHDIR          Вывод имени либо смена текущей папки.
CHKDSK         Проверка диска и вывод статистики.
CHKNTFS        Отображение или изменение выполнения проверки диска во время
               загрузки..
COMP           Сравнение содержимого двух файлов или двух наборов файлов.
COMPACT        Отображение и изменение сжатия файлов в разделах NTFS.
CONVERT        Преобразует тома FAT в NTFS. Вы не можете
               преобразовать текущий диск.
COPY           Копирование одного или нескольких файлов в другое место.
DEL            Удаление одного или нескольких файлов.
DIR            Вывод списка файлов и подпапок из указанной папки.
DISKPART       Отображает или настраивает свойства раздела диска.
ERASE          Удаляет один или несколько файлов.
FC             Сравнивает два файла или два набора файлов и
               отображает различия между ними.
FIND           Ищет текстовую строку в одном или нескольких файлах.
FINDSTR        Ищет строки в файлах.
FOR            Запускает указанную команду для каждого из файлов в наборе.
FORMAT         Форматирует диск для работы с Windows.
FSUTIL         Отображает или настраивает свойства файловой системы.
FTYPE          Отображает либо изменяет типы файлов, используемые при
               сопоставлении по расширениям имен файлов.
ICACLS         Отображает, изменяет, архивирует или восстанавливает
               списки ACL для файлов и каталогов.
LABEL          Создает, изменяет или удаляет метки тома для дисков.
MD             Создает каталог.
MKDIR          Создает каталог.
MOVE           Перемещает один или несколько файлов из одного каталога
               в другой.
OPENFILES      Отображает файлы, открытые для файлового ресурса удаленными пользователями.
PATH           Отображает или устанавливает путь поиска исполняемых файлов.
PAUSE          Приостанавливает выполнение пакетного файла и выводит сообщение.
POPD           Восстанавливает предыдущее значение текущего каталога,
               сохраненное с помощью команды PUSHD.
PRINT          Выводит на печать содержимое текстового файла.
PROMPT         Изменяет командную строку Windows.
PUSHD          Сохраняет текущий каталог, затем изменяет его.
RD             Удаляет каталог.
RECOVER        Восстанавливает данные, которые можно прочитать, с плохого или поврежденного диска.
REM            Записывает комментарии в пакетные файлы или файл CONFIG.SYS.
REN            Переименовывает файлы.
RENAME         Переименовывает файлы.
REPLACE        Заменяет файлы.
RMDIR          Удаляет каталог.
ROBOCOPY       Улучшенная служебная программа копирования файлов и деревьев папок
SETLOCAL       Начинает локализацию изменений среды в пакетном файле.
SHIFT          Изменяет положение заменяемых параметров в пакетных файлах.
SUBST          Связывает путь с именем диска.
TREE           Графически отображает структуру каталогов диска или
          пути.
TYPE           Отображает содержимое текстовых файлов.
VERIFY         Устанавливает режим проверки в Windows правильности записи
               файлов на диск.
VOL            Отображает метку и серийный номер тома для диска.
XCOPY          Копирует файлы и деревья папок.
3.	Вывести на экран номер версии DOS.
 
4.	Просмотреть иерархическую структуру сетевого дискаV:
 
5.	Создать на Рабочем столе каталог с именем FIO по первым буквам ваших фамилии, имени и отчества.

 
 
6.	Создать в своем каталоге на Рабочем столе подкаталог VERS.
 
7.	Создать текстовый файл my_text1.txt. с текстом определения файла и файловой системы, фамилией и инициалами автора.
 
8.	Скопировать файл my_text1 .txt с именем my_text2.txt.
 
9.	Просмотреть содержимое файла my_text1 .txt.
 
10.	Перейти на диск M: Просмотреть иерархическую структуру диска M:
 
11.	Перейти на диск С:
 
12.	Скопировать в папку VERS все файлы из подкаталога на диске С: с расширением .dat.
 
13.	Очистить экран.
 
 
14.	Соединить файлы my_text1.txt и my_text2.txt в файл add.dat.
 
15.	Переименовать my_text2.txt в text2.dat.
 
16.	Вывести на экран текущую дату.
 
17.	Вывести на экран текущее время.
 
18.	Просмотреть конфигурирование системных устройств.
 
Контрольные вопросы:
1.	Как создать файл, пользуясь командами MS DOS?
С помощью echo … файл.txt
2.	Какие типы файлов, различаемые файловой системой, вы знаете? 
Обычные файлы: текстовые, графические, исполнимые и другие типы данных.
Каталоги (папки): используемые для организации и хранения других файлов и каталогов.
Специальные файлы: такие как файлы устройств или ссылки.
Системные файлы: файлы, используемые операционной системой для ее работы (например, COMMAND.COM в MS-DOS).
3.	Какие основные задачи решаются файловой системой персонального компьютера? 
Идентификация файлов. Связывание его имени с выделенной частью ВУ.
Распределение внешней памяти между файлами. Для работы с файлом пользователю не требуется иметь информацию о местоположении этого файла на внешнем носителе.
Обеспечение надежности и отказоустойчивости. Стоимость информации может во много раз превышать стоимость компьютера.
Обеспечение защиты от несанкционированного доступа.
Обеспечение совместного доступа к файлам без дополнительных усилий со стороны пользователя.
Обеспечение высокой производительности ВС.
4.	Поясните различие между внутренними и внешними командами MS DOS. 
Внутренние команды — команды, встроенные непосредственно в операционную систему, которые выполняются в командной строке, например, dir, cd, del, copy.
Внешние команды — это программы, которые находятся в отдельных файлах (обычно в формате .exe или .com), которые загружаются и выполняются отдельно, например, format, xcopy.
5.	Как получить справочную информацию по командам MS DOS?
Чтобы получить справочную информацию по команде, нужно ввести команду с параметром `/?
6.	Перечислите основные возможности MS DOS по работе с каталогами.
Создание каталогов: команда mkdir или md.
Удаление каталогов: команда rmdir или rd.
Просмотр содержимого каталога: команда dir.
Переход между каталогами: команда cd.
7.	Какая команда MS DOS служит для создания каталогов? 
mkdir
8.	Как изменить текущий каталог? 
cd Путь
9.	Как переименовать каталог? 
rename стр_имя нов_имя
10.	Поясните различие в назначении команд RD и DELTREE. 
RD (rmdir) — удаляет пустые каталоги.
DELTREE — используется для удаления каталога и всех его содержимых, включая вложенные файлы и папки. Назовите возможности MS DOS по работе с файлами.
11.	Перечислите основные возможности MS DOS по работе с файлами.
Копирование файлов: команда copy.
Перемещение файлов: команда move.
Удаление файлов: команда del или erase.
Переименование файлов: команда rename или ren.
Просмотр содержимого файлов: команда type.
Поиск файлов: команда find.
12.	Как просмотреть содержимое файла?
Для просмотра содержимого текстового файла используется команда type
13.	Для чего служит команда COPY?
Команда copy служит для копирования файлов и каталогов.
14.	Какая команда служит для переименования файлов? 
rename старое_имя новое_имя
15.	Как переместить файл? 
move файл путь
16.	Назовите назначение команды DEL.
Удаление файлов
 
ЛАБОРАТОРНАЯ РАБОТА №8,9. Команды ФС
Порядок выполнения работы. 
1.	Внимательно изучите краткие теоретические сведения, перечень и назначение команд и конфигурационных файлов для администрирования файловых систем в ОС Linux и Windows.
2.	Для работы в терминальном режиме Windows запустите командную строку от имени администратора. Все выходные данные вносите в отчёт. 
3.	Перейдите на несистемный том диска и выведите на экран отчет о его состоянии. Сколько индексированных файлов и есть ли повреждённые сектора? 
 
Индексированных файлов – 9531
Повреждённых секторов - нет
4.	Проанализируйте указанный том, получите подробный отчет о его фрагментированности, файлах и папках, а также о свободном пространстве и MFT.
 
 
5.	Выведите перечень поддерживаемых команд в рамках fsutil.
 
6.	Выполните команды (выделены в тексте красным цветом) служебной программой командной строки fsutil с любым несистемным томом диска:
4.1	Запросите параметры поведения файловой системы. Прокомментируйте полученные результаты.
 
 
 
Состояние системы 
Параметр	Описание
disable8dot3 {1|0}	Отключает создание имен файлов длиной 8.3 символа в томах с форматом FAT и NTFS.
allowextchar {1|0}	Определяет, могут ли быть использованы символы из расширенного набора символов, включая диакритические знаки, в коротких именах файлов 8.3 в томах NTFS.
disablelastaccess {1|0}	Определяет, обновляет ли NTFS штамп времени последнего доступа в каждом каталоге при перечислении каталогов в томе NTFS. 
quotanotify частота	Настраивает частоту отчета о нарушении квот NTFS в системном журнале. Введите частоту (от 0 до 4294967295 секунд) записи нарушений квот в системный журнал. Значение по умолчанию составляет 1 час (3600 секунд). 

4.2	 Определите задан ли «грязный» бит тома. Поясните этот термин.
 
4.3	 Выведите содержимое корневого диска. Создайте в корне тома текстовый файл определённой длины. Создайте в корне папку, скопируйте в ней созданный ранее текстовый файл с новым именем более 8 символов, сделайте папку текущей. Задайте короткий формат имени скопированному файлу, затем удалите файл из папки, указав его короткое имя. Проверьте результат.
 
 
 
 
 
4.4	 Выведите все приводы на компьютере и их типы.
 
 
4.5	Перечислите сведения NTFS для указанного несистемного тома диска. Прокомментируйте полученные результаты.
 
Мы узнаём данные о диске: кол/во секторов, кластеров, свободных кластеров. Байт на секторе допустимую длину данных в MFT и другие данные о диске.
4.1	 Выведите тип ФС и основные статистические сведения тома.
 
4.2	 Выведите имя и серийный номер тома, сведения о поддержке учета регистра в именах файлов, именах файлов в формате Юникод, шифрования ФС и т.д.
 
4.3	 Запросите идентификатор текстового файла, созданного ранее в корневой папке.
 
4.4	 Переместите файл из корневой папки в созданную ранее, проверьте его идентификатор.
 
4.5	 Выведите информацию о свободном пространстве тома.
 
Контрольные вопросы. 
1.	Назначение и применение fsutil.

Является служебной программой командной строки, которая используется для выполнения связанных задач файловых систем FAT и NTFS.

2.	Что значит «монтировать» и «размонтировать» диск?

«Монтировать» диск — это подключение его к определённой папке, где будут доступны файлы с этого диска. 34 Монтирование может производиться автоматически (при загрузке системы), программно (при помощи сценариев, реагирующих на внутренние и внешние события системы) или пользователем вручную. 5

«Размонтировать» диск — отключение его, удаление точки монтирования тома из указанного каталога. После размонтирования диск отключается и делается недоступным для монтирования.

3.	По какому параметру, кроме полного имени может быть получен доступ к файлу в ФС?

По короткому формату имени.

4.	Каким образом с помощью командной строки можно выполнить разбиение диска на тома?

С помощью команд «diskpart» и «list volume»

 
ЛАБОРАТОРНАЯ РАБОТА №10,11. Пакетные файлы в ОС windows
Цель работы: Научиться работать с пакетными файлами
Пакетный файл для создания backup:
Запуск:
@echo off 
cls
echo start backup
mkdir backup
copy *.* backup 
echo endbackup
 
 
Запуск:
echo off 
cls
echo start backup
if exist backup\4.bat del backup\4.bat 
dir backup
copy *.* backupdir
dir backup
echo endbackup
 
 
Запись bat файла
 
 
 
Тестирование bat файла
Запись комментариев и использование аргументов:
 
Использование goto
 
Использование “::” для комментариев а также вывод аргументов
Создания cmd файла с использованием аргумента.
 
Запись файла
 
Вызов с указанием аргументом
 
Результат вызова без указания аргумента
 
Добавление проверки аргумента
 
Реузльтат вызова без аргумента
Использование shift
 
Запись файла
 
Вызов bat файла с аргументами
Результат:
 
 
 
Использования цикла for
 
 
Выполнение индивидуального задания:
Написать командный файл создающий текстовый файл со списком всех файлов в указанной директории и во всех вложенных директориях. Путь к директории передать в качестве аргумента.

Текстовый формат:
@echo off
if "%~1"=="" (
    echo No arguments were given
    exit /b 1
)
if not exist "%~1" (
    echo Error
    exit /b 1
)
set "output_file=files_%2.txt"
dir /s /b %1 > "%output_file%"
echo created %output_file%

 
Запись файла
 
Проверка на вызов с несуществующем пути и без аргумента.
 
Проверка на создание файла
 
Вывод содержимого файла
Практическая работа
Создание файлов:
 
Файл file1.txt
Создание жёстких ссылок:
 
file2.txt и file3.txt
Создание символических ссылок:
  
file2.txt
 
folder2
Проверки:
 
Изменения основного файла
 
Удаление основного файла
 
Проверка содержимого файла символической ссылки
 
Изменение основного файла
 
Проверка изменения файла по символической ссылки
 
Удаления основного файла и проверка файла символической ссылки
 
Проверка изначального содержания папки симв ссылки
 
Проверка изначального содержания основной папки
 
Добавления файлов в основную папку
 
Проверка сожержимого папки по симв ссылки 
Удаление файла в основной папке и проверка содержимого папки по симв ссылки
 
Удаление основной папки т проверка папки по симв ссылке
 
ЛАБОРАТОРНАЯ РАБОТА №12,13. WindowsPowerShell
Цель этой работы - научиться использованию ключевых возможностей Windows PowerShell для выполнения различных административных задач.
Предварительная подготовка справочной системы.
 
Обновление справочной систему
 
 Получения примеров использования соответствующего командлета
 
 Подробное описание командлета
 
Обращение к онлайн справке
 
Примеры ввода команд
 
Получение списка всех встроенных команд
 
 Просмотрит списока всех сервисов, запущенных на компьютере
 
Просмотрит списока всех процессов, запущенных в настоящий момент на компьютере

 
Получение информации только об одном процессе
 
Получение нформации обо всех запущенных процессах, начинающихся
На букву “w”
 
Использование функции автодополнения
 
Использование алиаса ps – Get-Process
 
Вывод списка всех алиасов
 
Получение конкретного алиаса
 
Получение алиасов с именем Item
 
Форматирование вывода
 
Вывод процессов в виде списка
 
Получение подрбной информации о различных формаах
 
Использование формата Wide
 
Использование формата Custom
 
Получение  всеx свойства объекта, 
полученного при выполнении команды Get-Process
 
Выполнение операции фильтрации

 
Выполнение операции сортировки
 
 
 
Преобразование команды и вывод необходимой нам информации
 
Сортировка объектов по свойству WS (Working Set) и выбор 5 процессов, 
занимающих больше всего памяти
 
Открытие и закрытие блокнота
 
Получение информации о том, что произойдёт при выполнении команды
 
Подтверждение выполнение команды
 
Запуск и блокнота и вывод его процесса
 
 
Получение списка методов, используемых этим объектом
 
Завершение процесса
 
Получение информации какой файл запустить процесс
Политики выполнения скриптов PS.
 
Просмотр текущего статуса политики выполнения
 
Установка политики Unrestricted
 
Включение политики AllSigned

 
Создание директории
 
Использование алиаса для создание директории
 
Создание файла
 
Создание файлов demo1.txt, demo2.txt, demo3.txt.
 
Копирование всех файлов с расширением *.txt в подкаталог TextFiles
 
Переход в подкаталог
 
Переименование файле с изменением его типа данных
 
Перемещение файла
 
Результат выполнения команд
 
Удаление директории TextFiles
 
Вывод содержимого всех bat файлов
 
Задания
1.	С помощью окружения PowerShellсоздайте произвольную папку. Перейдите в новую папку. Создайте в ней файлOUT1.txt, содержащий информацию обо всех запущенных на компьютере процессах (вывод команды ps).
PS C:> ni ПАПКА -itemtype directory
PS C:>slПАПКА
PS C:>ps> OUT1.txt
Решение:
 
 
 
2.	С помощью окружения PowerShell запустите процесс Wordpad. С помощью методов этого процесса получите следующую информациюSessionId, номер процесса (Handle), используемые системные библиотеки (Modules). Выведите эту информацию в файл OUT2.txt предварив каждый вывод заголовком (название соответствующего свойства).
PS D:\66\44> echo "SessionIDI" >.\OUT2.txt
PS D:\66\44> (ps notepad).SI >> .\OUT2.txt
PS D:\66\44>echo "Handle">> .\OUT2.txt
PS D:\66\44> (ps notepad).Handle>> .\OUT2.txt
PS D:\66\44> echo "Modules">> .\OUT2.txt
PS D:\66\44> (ps notepad).Modules >> .\OUT2.txt
Решение:
 
 
 
 
3.	С помощью окружения PowerShell создайте папки FOLDER1, FOLDER2. В FOLDER1 создайте 4 произвольных текстовых файла. Осуществите копирование этих файлов в FOLDER2 с заменой расширения txt на bak.
Решение:
 
 
 
4.	Напишите скрипт PS1, выполняющий все команды в задании 3. Перед выполнением скрипта удалите все предыдущие результаты.
Решение:
Текстовый вид:
Remove-Item -Path 'FOLDER2' -Force
Remove-Item -Path 'FOLDER1' -Force
ni -Path FOLDER1 -itemtype directory
ni -Path FOLDER2 -itemtype directory
for($i=1; $i -le 4; $i++)
{
ni -Path FOLDER1\File$i.txt -itemtype file
}
Get-ChildItem -Path 'Folder1' -Filter '*.txt' | ForEach-Object {Copy-Item -Path $_.FullName -Destination "$($_.DirectoryName)\..\FOLDER2\$($_.BaseName).bak"}
 
Запись команды
 
Запуск
 
 
Проверка результата
5.	Напишите скрипт, выполняющий команды в задании №2, используя вместо echo командлет Add-Content. Примеры использования смотреть по справке команды. Определите, алиасом какой команды является echo.
Решение:
Текстовый вид:
Add-Content -Path .\OUT2.txt -Value "SessionIDI"
(ps notepad).SI | Add-Content -Path .\OUT2.txt
Add-Content -Path .\OUT2.txt -Value "Handle"
(ps notepad).Handle | Add-Content -Path .\OUT2.txt
Add-Content -Path .\OUT2.txt -Value "Modules"
(ps notepad).Modules | Add-Content -Path .\OUT2.txt
 
Запись
 
Запуск
 
Проверка результата
 
Получение алиаса
 
ЛАБОРАТОРНАЯ РАБОТА №14. Работа со встроенной утилитой ОС WINDOWS «Диспетчер задач».
Цель работы: получить практические навыки работы с диспетчером задач, изучитьего функции и возможности.

Проверьте все способы запуска Диспетчера задач, занесите в отчёт, запомните для себя самый подходящий способ.
  
Запуск с помощью панели задач
 
Запуск с помощью меню пуск
Посмотрите с помощью Диспетчера задач (вкладка «Приложения»), какие задачи у пользователя работают в данный момент.
 
Просмотр процессов
Как в новой версии запустить новую задачу?
Чтоб запустить задачу в новой версии нажно нажать на кнопку “Запусть новую задачу”
 
Пример запуска программы через диспетчер задач
 
Запустите командную строку
 
Запуск cmd с помощью диспетчера задач
Введите команду Tasklist /SVC и нажмите клавишу ENTER.  
Перечислите процессы, обеспечивающие работу более, чем одной службы.
 
Получите дополнительные сведения о процессе, ассоциированном с Диспетчером задач.
  
Пользуясь командой WHERE и шаблоном поиска найдите все DLL-файлы в папке c:\windows (поиск должен быть рекурсивным, т.е. по всем вложенным папкам). Сделайте скриншот фрагмента поиска, назовите общее число таких файлов.
 
Запуск команды
 
Результат Запуска команды
 
Общее число dll файлов
 
С помощью команды ECHO и параметра %SystemRoot% выведите путь до системной папки. Приведите примеры нескольких переменных среды Windows 10, исследовав этот вопрос самостоятельно. 
 
Вывод пути системной папки
 
Использование переменной среды %USERPROFILE%
 
Использование переменной среды %APPDATA%

Выведите список процессов с PID в диапазоне от 0 до 700+№ студента по списку*10. Какие из перечисленных в теоретической части процессов попадают в этот список? Выполните перезагрузку системы, затем повторите указанный действия, сравните результат с предыдущим, сделайте вывод.
 
Вывод процессов c PID в диапазоне от 0 до 920 (номер в списке 22)

 
Вывод выше описанной команды после перезапуска системы

За что отвечает вкладка «Приложения»? 
Вкладка Приложения. Здесь можно найти список запущенных приложений и их состояние.

Существуют ли приложения, которые не следует завершать?
Нет, однако существуют некоторые процессы:
Процессы с атрибутами SYSTEM (системные процессы), NETWORK (сетевые процессы) и LOCALSERVICE (локальные службы). Останавливать выполнение этих процессов не рекомендуется, поэтому не устанавливайте данный флажок без необходимости.

Какая информация содержится во вкладке «Процессы»?
Вкладка Процессы. Перечислены все программы и процессы, запущенные в системе, – это основное окно для прекращения работы «зависших» программ или процессов.

Выпишите названия служб: криптографии, маршрутизации и удалённого доступа, диспетчера печати. Есть ли в списке службы с одинаковыми ИД процесса? Если да, то приведите пример и объясните почему?

Названия служб:
•	Криптографии – CryptSvc
•	Маршрутизации – SmsRouter, dmwappushservice
•	Удалённого доступа – WinRM
•	Диспетчер печати - Spooler
Например KeyIso, SamSs и VaultSvc имеют одинаковый PID - 1108, это указывает на то, что они работают в рамках одного процесса. Несколько служб могут быть объединены в один процесс для оптимизации использования ресурсов.
 
Пример служб с одинаковыми PID
 
Какую информацию предоставляет вкладка Службы?
Вкладка Службы. Содержит список программ, которые работают в фоновом режиме.


Зачем нужна вкладка Быстродействие?
Вкладка Быстродействие. Основная вкладка для оценки производительности операционной системы.


Что такое файл подкачки? Можно ли задать его размер?
Количество физической и виртуальной памяти, используемой всеми выполняемыми процессами. 
Чтобы настроить файл подкачки в Windows 11, выполните следующие шаги: 
1.	Откройте меню «Пуск» и перейдите в «Параметры». 
2.	В списке откройте категорию «Система» и перейдите в раздел «О системе». 
3.	В подразделе «Характеристики устройства» нажмите кнопку «Дополнительные параметры системы». 
4.	Появится окно «Свойства системы», в разделе «Быстродействие» нажмите кнопку «Параметры». 
5.	В новом окне откройте вкладку «Дополнительно» и нажмите кнопку «Изменить». 
6.	Сверху снимите галочку с параметра «Автоматически выбирать объём файла подкачки». 
7.	Выберите вариант «Указать размер» и впишите одинаковое значение в оба поля в мегабайтах. 
8.	Нажмите кнопку «Задать», а затем «ОК». Перезагрузите устройство для применения изменений. 


Что показывает вкладка Сеть?
Вкладка Сеть. Отображает объём передаваемых по локальной сети данных.


Можно ли по сетевой активности судить о вирусной активности?
Да, анализ сетевой активности может быть одним из способов выявления подозрительной или вирусной активности на компьютере. Вирусы, трояны, бэкдоры и другие вредоносные программы часто используют интернет-соединение для передачи данных, получения команд от злоумышленников или загрузки дополнительных вредоносных компонентов. 

Какие функции показывает вкладка Пользователи.
Вкладка Пользователи. С помощью этой вкладки можно увидеть список всех пользователей, подключенных к вашему компьютеру по локальной сети. В противном случае будет указана только одна учётная запись пользователя.


Контрольные вопросы:
1.	Сколько экземпляров svchost.exe может быть запущенно на компьютере? Почему?
svchost.exe – это главный системный процесс для тех служб, которые запускаются из динамически загружаемых библиотек (DLL-файлов). И действительно несколько экземпляров процесса svchost.exe могут быть запущены одновременно (но с разными PID* (PID ─ это идентификатор пакета.)). Так как каждый из таких экземпляров представляет собой определённую преимущественно системную службу или же группу служб. Эти группы определены в следующем разделе реестра:

2.	Что такое spoolsv.exe?
spoolsv.exe – процесс отвечает за обработку процессов печати на локальном компьютере в операционных системах MicrosoftWindows. Служба spooler ответственна за управление заданиями на печать и передачу факсимильных сообщений.

3.	Чем отличается файл подкачки от виртуальной памяти? Где можно увидеть?
•	Виртуальная память — это концепция, которая позволяет операционной системе использовать жесткий диск для расширения оперативной памяти (RAM).
•	Файл подкачки (pagefile.sys) — это физический файл на жестком диске, используемый для хранения данных, которые не помещаются в оперативной памяти.

4.	Дескриптор файла это -…
Дескрипторы. Число уникальных идентификаторов объектов, используемых процессами. Это значение представляет интерес главным образом для ИТ-специалистов и программистов.

5.	Что такое службы? Для чего предназначены?
Службы Windows (англ. WindowsService, сервисы) – приложения, автоматически запускаемые системой при запуске Windows и выполняющиеся вне зависимости от статуса пользователя. Они предназначены для управления системными ресурсами, обеспечения работы сетевых служб, безопасности, обновлений и других задач без участия пользователя.

6.	Что необходимо сделать, чтобы запустить настройку системы?
Для запуска настройки системы можно использовать команду msconfig в строке поиска или командной строке. Это откроет утилиту Конфигурация системы, где можно настроить параметры загрузки, служб и автозагрузки.

7.	Что обеспечивает обычный запуск операционной системы?
Обычный запуск операционной системы загружает все драйверы, службы и программы, которые настроены для автоматического запуска. Это стандартный режим работы ОС, при котором доступны все функции и возможности.

8.	В каком случае рекомендуется использовать диагностический запуск?
Диагностический запуск рекомендуется использовать для устранения неполадок, когда система работает некорректно. В этом режиме загружаются только основные драйверы и службы, что позволяет выявить проблемные программы или драйверы.

9.	Что такое system.ini? Для чего он нужен?
system.ini — это конфигурационный файл, который использовался в старых версиях Windows (например, Windows 9x) для хранения настроек системы, таких как загрузка драйверов и параметров оборудования. В современных версиях Windows он используется редко, так как его функции заменены реестром.

10.	Что обеспечивает раздел boot?
Раздел boot содержит загрузочные файлы операционной системы, такие как загрузчик (bootloader), который отвечает за запуск ОС. Он также может содержать конфигурационные файлы, например, boot.ini (в старых версиях Windows) или BCD (в современных версиях).

11.	Какие функции возложены на файл boot.ini?
Файл boot.ini использовался в Windows XP и более ранних версиях для настройки параметров загрузки:
•	Определение доступных операционных систем
Файл boot.ini содержит список операционных систем, установленных на компьютере. Это позволяет пользователю выбирать, какую ОС загружать, если на компьютере установлено несколько систем.
•	Указание расположения операционной системы
В файле boot.ini указывается, на каком диске и в каком разделе находится загрузочная операционная система. Например, он может содержать путь к загрузочному разделу Windows.
•	Настройка параметров загрузки
Файл boot.ini позволяет задавать дополнительные параметры загрузки, такие как:
o	/fastdetect — отключает обнаружение некоторых устройств для ускорения загрузки.
o	/noguiboot — отключает графическую заставку при загрузке.
o	/safeboot — загрузка в безопасном режиме.
o	/maxmem — ограничение объема оперативной памяти, используемой системой (для диагностики).
•	Управление временем выбора ОС
В файле boot.ini можно настроить время, в течение которого пользователь может выбрать операционную систему для загрузки. Если выбор не сделан в течение этого времени, загружается система по умолчанию.
•	Указание загрузочного раздела по умолчанию
Файл boot.ini определяет, какая операционная система будет загружена по умолчанию, если пользователь не сделает выбор в меню загрузки.

12.	Что такое Application Layer Gateway Service?
Application Layer Gateway Service (ALG) — это служба Windows, которая обеспечивает поддержку сетевых протоколов и помогает приложениям работать через брандмауэр. 

13.	Чтот такое timeout, rdisk(0), disk(0), default?
•	rdisk(0) — обозначение первого RAID-массива или жесткого диска.
•	disk(0) — обозначение первого физического диска.
•	default — указывает на загрузочный раздел по умолчанию.
Эти термины используются в конфигурационных файлах загрузчика, например, в boot.ini
•	timeout – время ожидания выбора операционной системы в меню загрузчика

14.	Что делает Computer Browser?
Служба Computer Browser отвечает за обнаружение и отображение списка компьютеров в локальной сети. Она собирает информацию о доступных устройствах и предоставляет ее другим компьютерам в сети.

15.	Расскажите про Cryptographic Services?
Cryptographic Services — это служба Windows, которая обеспечивает криптографические функции, такие как управление сертификатами, проверка подписи файлов и обновление корневых сертификатов. Она используется для обеспечения безопасности и целостности данных в системе.

 
ЛАБОРАТОРНАЯ РАБОТА №15. Архивация данных. Сравнение методов сжатия информации.
Цель работы: получить практические навыки работы с программой-архиватором WinRAR, научиться объединять файлы в архив, задавать параметры архива, осуществлять операции с архивными файлами.
Вариант 10 - XLS. * и TXT. *


Код игры камень ножниц бумага
# Импортирование нужных методов
from tkinter import *
from tkinter import ttk
from tkinter import messagebox, font
import webbrowser
from validate_email import validate_email
import sqlite3
import random
import string
from PIL import Image
import re
# Кастомная библиотека для tkinter для создание более современново дизайна
from customtkinter import *


# Родительский класс для всех последующих окон хранящий в себе необходимые переменные и методы
class Parent(CTk):
    # Переменные необходимые для дальнейшей работы программы
    login = 'unknown'  # Переменная хранящяя текущий логин
    bg_cl = "#141a2a"  # Переменная хранящяя цвет заднего фона
    fg_cl = 'white'  # Переменная хранящяя цвет переднего фона (шрифта)
    log_cl = '#1C202B'  # Переменная хранящяя цвет заднего фона для загаловков
    bg_cl_aureg = '#212633'  # Переменная хранящяя цвет заднего фона для некоторых окон
    font_color = 'white'

    set_appearance_mode("dark")  # Modes: system (default), light, dark
    set_default_color_theme("dark-blue")  # Themes: blue (default), dark-blue, green
    mode = "dark"

    def __init__(self, parent):
        CTk.__init__(self, parent)
        self.root = parent

    # Метод возвращает дефолтный фон
    @staticmethod
    def default_font_set(family='Arial', size=18):
        return CTkFont(family, size, "bold")

    # Метод для создания нового окна и закрытия старого
    @staticmethod
    def new_window(create, self_f=None):
        if self_f is not None:
            self_f.destroy()
        new_window = create(None)
        new_window.mainloop()

    # Метод для создания таблицы
    @staticmethod
    def create_grid(self, row_index_amount=1, row_width=1, column_index_amount=1, column_width=1):
        for i in range(column_index_amount):
            self.grid_columnconfigure(i, weight=column_width)
        for i in range(row_index_amount):
            self.grid_rowconfigure(i, weight=row_width)

    # Метод для добавления кнопки
    @staticmethod
    def create_button(parent, text, command, row, column, padx=5, pady=5, sticky="NSEW", **kwargs):
        button = CTkButton(parent, text=text, command=command, **kwargs)
        button.grid(row=row, column=column, sticky=sticky, padx=padx, pady=pady)
        return button

    # Метод для проверки ввода
    @staticmethod
    def on_validate(string_to_check, r, ignor):
        if bool(re.compile(r).fullmatch(string_to_check) or string_to_check == ignor):
            return True  # Разрешить изменение
        return False  # Запретить изменение


# Класс основного окна игры
class RockPaperScissorsGame(Parent):
    def __init__(self, parent):
        Parent.__init__(self, parent)
        # Обьявления пересенных
        self.y = None
        self.x = None
        self.img_ref_bot = None
        self.img_ref_user = None
        self.statistica = None
        self.canvas_result = None
        self.image_autorization = None
        self.canvas = None
        self.root = parent

        connection2 = sqlite3.connect('database.db')
        cursor = connection2.cursor()

        sqlite_select_query = """SELECT * from leaderBoard where login = ?"""
        db_list = tuple(cursor.execute(sqlite_select_query, (Parent.login,)).fetchall())

        index = 0
        for i in range(len(db_list)):
            if Parent.login in db_list[i]:
                index = i

        connection2.commit()
        connection2.close()

        self.wins_count = [db_list[index][1], db_list[index][2], db_list[index][3]]
        self.temp = 0
        self.choice = ['0']

        # Кол-во сыграных ходов пользователя и бота
        self.user_choices = [db_list[index][4], db_list[index][5], db_list[index][6]]
        self.computer_choices = [db_list[index][7], db_list[index][8], db_list[index][9]]

        # Словарь для орпеделения победы и для выбора хода ботом
        self.winComb = {
            'Ножницы': 'Камень',
            'Бумага': 'Ножницы',
            'Камень': 'Бумага'
        }

        # Переменная хранящее выбор бота
        self.bot_choice = ''

        # Переменная хранящяя статистику
        self.stats = ''
        self.interface()

    def interface(self):

        self.geometry("940x740")

        # Обьявления canvas
        self.canvas = CTkCanvas(self, width=400, height=550, bg="#313744")
        self.canvas.grid(row=1, column=0, padx=0, columnspan=3, rowspan=4, sticky='NSEW')
        self.config(bg=Parent.bg_cl)
        self.canvas.create_text((self.canvas.winfo_width() / 2, self.canvas.winfo_height() / 2),
                                text="Выберите камень, ножницы или бумагу", angle=50)

        # Создание таблицы
        self.create_grid(self, row_index_amount=5, column_index_amount=3)

        # Кнопки "Камень", "Ножницы", "Бумага"
        for idx, item in enumerate(("Камень", "Ножницы", "Бумага")):
            self.create_button(self,
                               corner_radius=0,
                               border_width=1, padx=0, pady=0,
                               text=item, font=Parent.default_font_set(size=30),
                               command=lambda choice=item: self.play(choice),
                               row=0, column=idx, border_color='white',
                               width=100, height=40, fg_color=Parent.bg_cl, text_color=Parent.fg_cl
                               )

        # Кнопка сохранения
        self.create_button(self, corner_radius=0,
                           border_width=1, padx=0, pady=0,
                           text="Сохранить статистику",
                           command=self.save_stats, font=Parent.default_font_set(size=30),
                           row=0, column=3,
                           width=200, height=40, fg_color=Parent.bg_cl, text_color=Parent.fg_cl
                           )

        # Кнопка перехода на приветственный экран
        self.image_autorization = CTkImage(
            dark_image=Image.open("Menu.png"), size=(70, 70))
        self.create_button(self, corner_radius=0,
                           border_width=1, padx=0, pady=0,
                           image=self.image_autorization, text="", command=lambda: self.new_window(Welcome, self),
                           width=70, height=70, fg_color=Parent.bg_cl, bg_color=Parent.bg_cl, row=0, column=4)

        # Canvas для вывода результатов
        self.canvas_result = CTkCanvas(self, width=300, height=300, bg=Parent.bg_cl)
        self.canvas_result.grid(row=1, column=3, columnspan=2, sticky='NSEW', padx=0, pady=0, )

        # Label для статистики
        self.statistica = CTkLabel(
            self, text='Статистика', width=40, height=14, bg_color=Parent.bg_cl,
            fg_color=Parent.bg_cl, font=Parent.default_font_set(size=24), text_color=Parent.font_color)
        self.statistica.grid(row=2, column=3, columnspan=2, sticky='NSEW', padx=0, pady=0)

    # Метод для задания параметров для изображения
    def image_place(self, pick, st, us):
        img = PhotoImage(file=pick)
        if us == "user":
            self.img_ref_user = img
        elif us == "bot":
            self.img_ref_bot = img
        self.x = (self.canvas.winfo_width() - img.width()) // 2  # Центрируем по горизонтали
        if st == "S":
            self.y = self.canvas.winfo_height() - img.height() - 40  # Позиционируем сверху
        elif st == "N":
            self.y = self.canvas.winfo_height()  # Позиционируем снизу

    # Метод срабатываемые при нажатии кнопок Камень/Ножницы/Бумага
    def play(self, user_choice):

        self.choice.append(user_choice)

        # Анализ бота
        if user_choice == self.choice[len(self.choice) - 2]:  # Инкремент переменной temp в случаи повторения выбора
            self.temp += 1
        else:
            self.temp = 0
        if self.temp > 2:  # Изменение выбора бота при повторении одного и того же выбора больше двух раз
            self.bot_choice = self.winComb[user_choice]
        else:
            self.bot_choice = random.choice(list(self.winComb.keys()))  # Придание боту рандомного выбора

        #######################################################################################

        # Расстановка изображений
        match user_choice:
            case 'Камень':
                self.user_choices[0] += 1
                self.image_place("Камень.png", "N", "user")
                self.canvas.create_image(self.x, self.y, image=self.img_ref_user, anchor="sw")
            case 'Ножницы':
                self.user_choices[1] += 1
                self.image_place("Ножницы.png", "N", "user")
                self.canvas.create_image(self.x, self.y, image=self.img_ref_user, anchor="sw")
            case 'Бумага':
                self.user_choices[2] += 1
                self.image_place("Бумага.png", "N", "user")
                self.canvas.create_image(self.x, self.y, image=self.img_ref_user, anchor="sw")

        temp_bot_choice = self.bot_choice + ".png"
        self.image_place(temp_bot_choice, "S", "bot")
        self.canvas.create_image(self.x, self.y, image=self.img_ref_bot, anchor="sw")

        #######################################################################################

        # Вывод поражения/победы/ничьи
        rot_angle = random.randint(-70, 70)
        win_font = font.Font(family="Helvetica", size=25, weight="bold")

        if user_choice == self.winComb[self.bot_choice]:  # Проверка на победу
            self.wins_count[0] += 1
            print("Победа")
            self.canvas.config(bg="#11792b")

            self.canvas_result.delete("all")
            self.canvas_result.config(bg="#11792b")
            self.canvas_result.create_text(self.canvas_result.winfo_width() // 2,
                                           self.canvas_result.winfo_height() // 2,
                                           text="!!!ПОБЕДА!!!", angle=rot_angle, font=win_font, fill="#ffffff")

        elif self.bot_choice == user_choice:  # Проверка на ничью
            print("Ничья")
            self.wins_count[1] += 1
            self.canvas.config(bg="#2c364e")

            self.canvas_result.delete("all")
            self.canvas_result.config(bg="#2c364e")
            self.canvas_result.create_text(self.canvas_result.winfo_width() // 2,
                                           self.canvas_result.winfo_height() // 2,
                                           text="...НИЧЬЯ...", angle=rot_angle, font=win_font, fill="#ffffff")

        else:  # Проверка на поражение
            self.wins_count[2] += 1
            print("Поражение")
            self.canvas.config(bg="#da314a")

            self.canvas_result.delete("all")
            self.canvas_result.config(bg="#da314a")
            self.canvas_result.create_text(self.canvas_result.winfo_width() // 2,
                                           self.canvas_result.winfo_height() // 2,
                                           text="ПОРАЖЕНИЕ(((", angle=rot_angle, font=win_font, fill="#ffffff")

        self.computer_choices[list(self.winComb.values()).index(self.bot_choice)] += 1

        # Заполнение статистики
        self.stats = (
            f"Количество побед: {self.wins_count[0]}                           \n"
            f"Количество ничей: {self.wins_count[1]}\n"
            f"Количество поражений: {self.wins_count[2]}\n\n"

            f"Игрок:\n"
            f"\tСыграно камня: {self.user_choices[0]}\n"
            f"\tСыграно ножниц: {self.user_choices[1]}\n"
            f"\tСыграно бумаги: {self.user_choices[2]}\n"

            f"Бот:\n"
            f"\tСыграно камня: {self.computer_choices[0]}\n"
            f"\tСыграно ножниц: {self.computer_choices[1]}\n"
            f"\tСыграно бумаги: {self.computer_choices[2]}\n"
        )

        self.statistica.configure(text=self.stats, font=self.default_font_set(size=20),
                                  justify=LEFT,
                                  underline=0,
                                  wraplength=1000,
                                  padx=20,
                                  pady=20
                                  )

        connection = sqlite3.connect('database.db')
        cursor = connection.cursor()

        sqlite_update_query = """Update leaderBoard set win_count =?,draw_count =?,lost_count=?,cobble_player=?,
                scissors_player=?,papper_player=?,cobble_bot=?,scissors_bot=?,papper_bot=?
                where login = ?"""
        column_values = (self.wins_count[0], self.wins_count[1], self.wins_count[2],
                         self.user_choices[0], self.user_choices[1], self.user_choices[2], self.computer_choices[0],
                         self.computer_choices[1], self.computer_choices[2], Parent.login)
        cursor.execute(sqlite_update_query, column_values)

        connection.commit()
        connection.close()

    # Метод сохранения статистики в txt файл
    def save_stats(self):
        with open("statistics.txt", "w") as f:
            f.write(f"Количество побед: {self.wins_count[0]}\n"
                    f"Количество ничей: {self.wins_count[1]}\n"
                    f"Количество поражений: {self.wins_count[2]}\n\n"

                    f"Игрок:\n"
                    f"\tСыграно камня: {self.user_choices[0]}\n"
                    f"\tСыграно ножниц: {self.user_choices[1]}\n"
                    f"\tСыграно бумаги: {self.user_choices[2]}\n"

                    f"Бот:\n"
                    f"\tСыграно камня: {self.computer_choices[0]}\n"
                    f"\tСыграно ножниц: {self.computer_choices[1]}\n"
                    f"\tСыграно бумаги: {self.computer_choices[2]}\n")
        messagebox.showinfo("Сохранение", "Статистика сохранена в файл statistics.txt")


# Класс стартового окна
class StartScreen(Parent):
    def __init__(self, parent):
        Parent.__init__(self, parent)
        self.logo_image = None
        self.root = parent
        self.interface()

    # Метод интерфейса
    def interface(self):
        # Заголовок
        self.title("Камень, Ножницы, Бумага")
        self.geometry("1000x740")
        self.config(bg=self.bg_cl_aureg)  # Цвет фона
        self.resizable(False, False)

        (CTkLabel(self, text="Добро пожаловать в игру!", font=self.default_font_set(size=40),
                  text_color=Parent.font_color,
                  width=1000, height=60, bg_color=self.fg_cl, fg_color=self.bg_cl)
         .grid(row=0, columnspan=3, sticky='NSEW'))

        self.logo_image = CTkImage(dark_image=Image.open("StartScreenImageDarkTheme.png"),
                                   light_image=Image.open("StartScreenImageLightTheme.png"),
                                   size=(400, 670))
        CTkLabel(self, image=self.logo_image, text='').grid(row=1, rowspan=5, column=1)

        # Кнопки
        buttons = [
            ("Начать игру", lambda: self.new_window(Autorisation, self)),
            ("Правила игры", lambda: webbrowser.open
            ("https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BC%D0%B5%D0%BD%D1%8C,"
             "_%D0%BD%D0%BE%D0%B6%D0%BD%D0%B8%D1%86%D1%8B,_%D0%B1%D1%83%D0%BC%D0%B0%D0%B3%D0%B0")),
            ("Ссылка на проэкт", lambda: webbrowser.open
            ("https://github.com/ed1ct7?tab=repositories")),
            ("Университет", lambda: webbrowser.open
            ("https://guap.ru/?ysclid=m4it8ih8fv471846935#")),
            ("Выход рабочий стол", self.destroy)
        ]

        for i, (text, command) in enumerate(buttons, start=1):
            self.create_button(
                self,
                text=text,
                hover_color="#55a19d",
                fg_color=self.bg_cl,
                corner_radius=0,
                font=self.default_font_set(size=36),
                text_color=Parent.font_color,
                width=180,
                height=100,
                command=command,
                row=i,
                column=0,
                padx=30,
                pady=5,
                sticky='EW'
            )


# Класс окна для авторизации пользователя
class Autorisation(Parent):
    def __init__(self, parent):
        Parent.__init__(self, parent)
        self.error_password = None
        self.error_login = None
        self.image_autorization = None
        self.entry_password = None
        self.image_home = None
        self.login_entry = None
        self.root = parent
        self.interface()

    def interface(self):
        self.title("Окно авторизации")
        self.geometry("600x550")
        self.config(bg=self.bg_cl_aureg)
        self.resizable(False, False)

        row_counter = 0

        # Заголовок
        (CTkLabel(self, text="Авторизация", font=self.default_font_set(size=40),
                  bg_color=self.log_cl, width=600, height=70, text_color=Parent.font_color, )
         .grid(row=row_counter, columnspan=3, pady=10, padx=1, sticky="NSEW"))

        row_counter += 1
        # Логин
        self.login_entry = CTkEntry(self, placeholder_text="Введите логин",
                                    font=self.default_font_set(size=32),
                                    width=550, height=100,
                                    validate="key",
                                    validatecommand=(self.register
                                                     (lambda value:
                                                      self.on_validate(value, r'^[a-zA-Z0-9._%+-]{0,30}$',
                                                                       'Введите логин')), "%P")
                                    )
        self.login_entry.grid(row=row_counter, columnspan=3, pady=(10, 0), padx=1)

        row_counter += 1

        self.error_login = CTkLabel(self, text='', bg_color=self.bg_cl_aureg,
                                    font=self.default_font_set(size=20), text_color='#da314a')
        self.error_login.grid(row=row_counter, columnspan=3, pady=(5, 15))

        row_counter += 1

        # Пароль
        self.entry_password = CTkEntry(self, placeholder_text="Введите пароль",
                                       font=self.default_font_set(size=32),
                                       width=550, height=100, show='*',
                                       validate="key",
                                       validatecommand=(self.register
                                                        (lambda value:
                                                         self.on_validate(value, r'^[^[^а-яА-Я]{0,30}$]*$',
                                                                          'Введите пароль')), "%P")
                                       )
        self.entry_password.grid(row=row_counter, column=0, columnspan=3, pady=(2, 0), padx=1)

        row_counter += 1

        self.error_password = CTkLabel(self, text='', bg_color=self.bg_cl_aureg,
                                       font=self.default_font_set(size=20), text_color='#da314a')
        self.error_password.grid(row=row_counter, columnspan=3, pady=(5, 30))

        row_counter += 1

        reg_button = CTkButton(self, text="Войти", command=self.autorize, width=340, height=60,
                               font=self.default_font_set(size=32))
        reg_button.grid(row=row_counter, column=1, padx=1, pady=20)

        # Навигация
        self.image_home = CTkImage(dark_image=Image.open("HomeButton.png"),
                                   size=(50, 50))
        back_to_start = CTkButton(self, image=self.image_home, text="", width=100,
                                  command=lambda: self.new_window(StartScreen, self))
        back_to_start.grid(row=row_counter, column=0, padx=(22, 1), pady=10)

        self.image_autorization = CTkImage(dark_image=Image.open("RegScreen.png"),
                                           size=(50, 50))
        back_to_auth = CTkButton(self, image=self.image_autorization, text="", width=100,
                                 command=lambda: self.new_window(Registration, self))
        back_to_auth.grid(row=row_counter, column=2, padx=(1, 22), pady=10)

    def autorize(self):
        if self.entry_password.get() != '' and self.login_entry.get() != '':
            self.error_login.configure(text="")
            self.error_password.configure(text="")
            # Устанавливаем соединение с базой данных
            connection = sqlite3.connect('database.db')
            cursor = connection.cursor()
            # Создаем таблицу Users
            t_bool = True

            try:
                db_list = tuple(cursor.execute('SELECT * FROM Users').fetchall())
            except sqlite3.Error:
                db_list = ((),)
                t_bool = True
            for i in range(len(db_list)):
                if db_list[i][0] == self.login_entry.get() and db_list[i][1] == self.entry_password.get():
                    Parent.login = self.login_entry.get()
                    messagebox.showinfo("Вход", f"Добро пожайловать {Parent.login}")
                    self.new_window(Welcome, self)
                    t_bool = False
            if t_bool:
                self.error_login.configure(text="Аккаунт с таким логином и паролем не найден")

            connection.commit()
            connection.close()
        else:
            if self.entry_password.get() == '':
                self.error_password.configure(text="Поле пароль не заполненно")
            else:
                self.error_password.configure(text="")

            if self.login_entry.get() == '':
                self.error_login.configure(text="Поле логин не заполненно")
            else:
                self.error_login.configure(text="")


# Класс окна для регистрации пользователя
class Registration(Parent):
    def __init__(self, parent):
        Parent.__init__(self, parent)
        self.radio_button_gender = None
        self.age_error_label = None
        self.email_error_label = None
        self.image_autorization = None
        self.image_home = None
        self.gender_var = None
        self.entry_age = None
        self.email_entry = None
        self.entry_password = None
        self.login_entry = None
        self.root = parent
        self.interface()

    # Метод интерфейса
    def interface(self):
        self.title("Окно регистрации")
        self.geometry("650x760")
        self.config(bg=self.bg_cl_aureg)
        self.resizable(False, False)

        # переменная для упрощённого добавления виджета между других виджетов
        row_num = 0

        # Создание таблицы
        self.create_grid(self, 10, 1, 5, 1)

        # Заголовок
        (CTkLabel(self, text="Регистрация аккаунта", font=self.default_font_set(size=40),
                  bg_color=self.log_cl, text_color=Parent.font_color)
         .grid(row=row_num, columnspan=5, pady=0, padx=0, sticky="NSEW"))

        row_num += 1

        # entry для логина
        self.login_entry = CTkEntry(self, placeholder_text="Введите логин", width=600, height=50,
                                    font=self.default_font_set(size=24),
                                    validate="key",
                                    validatecommand=(self.register
                                                     (lambda value:
                                                      self.on_validate(value, r'^[a-zA-Z0-9._%+-]{0,30}$',
                                                                       'Введите логин')), "%P")
                                    )
        self.login_entry.grid(row=row_num, columnspan=5, column=0, pady=10, padx=20)

        row_num += 1

        # entry для пароля
        self.entry_password = CTkEntry(self, placeholder_text="Введите пароль", width=480, height=50,
                                       font=self.default_font_set(size=24),
                                       validate="key",
                                       validatecommand=(self.register
                                                        (lambda value:
                                                         self.on_validate(value, r'^[^а-яА-Я]{0,50}$',
                                                                          'Введите пароль')), "%P"
                                                        )
                                       )
        self.entry_password.grid(row=row_num, column=0, columnspan=4, padx=(5, 1))

        (CTkButton(self, text="Ген",
                   command=self.password_generator, width=100, height=50,
                   font=self.default_font_set(size=24), text_color=Parent.font_color, )
         .grid(row=row_num, column=3, columnspan=2, sticky='E', padx=(0, 25)))

        row_num += 1

        # Почта
        self.email_entry = CTkEntry(self, placeholder_text="Введите почту", width=600, height=50,
                                    font=self.default_font_set(size=24),
                                    validate="key",
                                    validatecommand=(self.register
                                                     (lambda value:
                                                      self.on_validate(value, r'^[a-zA-Z0-9._%+@-]{0,50}$',
                                                                       'Введите почту')), "%P"
                                                     )
                                    )
        self.email_entry.grid(row=row_num, columnspan=5, column=0, pady=10, padx=20)

        row_num += 1

        self.email_error_label = CTkLabel(self, bg_color=Parent.bg_cl_aureg, text='')
        self.email_error_label.grid(row=row_num, columnspan=5, column=0)

        row_num += 1

        (CTkLabel(self, text="Введите год рождения", font=Parent.default_font_set(size=24),
                  text_color=Parent.font_color,
                  bg_color=Parent.log_cl, width=140, height=50)
         .grid(row=row_num, columnspan=5, pady=5, padx=0, sticky='NSEW'))

        row_num += 1

        # Год рождения
        self.entry_age = CTkComboBox(self,
                                     values=[str(i) for i in range(1950, 2025)],
                                     width=600 - 40, height=50,
                                     font=self.default_font_set(size=24),
                                     )
        self.entry_age.grid(row=row_num, columnspan=5, pady=5, padx=10)

        row_num += 1

        # Лейбл для вывода ошибки при вводе возраста
        self.age_error_label = CTkLabel(self, bg_color=Parent.bg_cl_aureg, text='')
        self.age_error_label.grid(row=row_num, columnspan=5, column=0)

        row_num += 1

        # Лейбл для пола
        (CTkLabel(self, text="Выберите пол", font=Parent.default_font_set(size=24), text_color=Parent.font_color,
                  bg_color=self.log_cl, width=140, height=50)
         .grid(row=row_num, columnspan=5, pady=(5, 0), padx=0, sticky='NSEW'))

        row_num += 1

        (CTkLabel(self, text='', bg_color=Parent.bg_cl_aureg, fg_color=Parent.log_cl, height=50, width=400,
                  corner_radius=10000)
         .grid(row=row_num, columnspan=5, rowspan=2,
               pady=5, padx=0))
        self.gender_var = StringVar(value="Мужчина")

        i = 1
        for gender in ["Муж", "Жен", "Другое"]:
            self.radio_button_gender = CTkRadioButton(self, text=gender,
                                                      variable=self.gender_var,
                                                      value=gender,
                                                      bg_color=Parent.log_cl,
                                                      text_color=Parent.font_color,
                                                      font=self.default_font_set(size=28))
            self.radio_button_gender.grid(row=row_num, column=i, pady=5, padx=1)
            i += 1
        self.radio_button_gender.select("Другое")

        row_num += 1

        # (CTkLabel(self, bg_color=self.bg_cl_aureg, text='', text_color=Parent.bg_cl).
        #  grid(row=row_num, columnspan=5, column=0))

        row_num += 1

        reg_button = CTkButton(self, text="Зарегистрировать", command=self.reg,
                               width=420, height=80,
                               text_color=Parent.font_color,
                               font=self.default_font_set(size=32))
        reg_button.grid(row=row_num, column=1, columnspan=3, padx=1, pady=40)

        # Навигация
        self.image_home = CTkImage(dark_image=Image.open("HomeButton.png"), size=(70, 70))
        back_to_start = CTkButton(self, image=self.image_home, text="", width=50,
                                  command=lambda: self.new_window(StartScreen, self))
        back_to_start.grid(row=row_num, column=0, padx=5, pady=10)

        self.image_autorization = CTkImage(dark_image=Image.open("BackButton.png"), size=(70, 70))
        back_to_auth = CTkButton(self, image=self.image_autorization, text="", width=50,
                                 command=lambda: self.new_window(Autorisation, self))
        back_to_auth.grid(row=row_num, column=4, padx=5, pady=10)

    # Метод для генерации пароля
    def password_generator(self):
        cdr_rand_choice = 0
        self.entry_password.delete(0, END)
        cdp_choice_arr = {0: string.ascii_letters, 1: string.digits, 2: string.punctuation}  # Let, Dig, Pun
        cdp_choice_count_arr = [0, 0, 0]  # Хранение количетсва каждого вида символа
        pos_count = 15
        password = ""
        for i in range(pos_count):  # Заполнение
            tbool = True
            while tbool:  # Проверка и замена в случае отсутствия одного из вида символов
                cdr_rand_choice = random.randint(0, 2)
                tbool = (cdp_choice_count_arr[cdr_rand_choice] > pos_count - 2)
            password += "".join(random.choice(cdp_choice_arr[cdr_rand_choice]))  # Рандомное заполнение
        self.entry_password.insert(0, password)

    # Метод для регистрации аккаунта
    def reg(self):
        try:
            int(self.entry_age.get())
            # Устанавливаем соединение с базой данных
            if (self.email_entry.get() == '' or self.entry_password.get() == '' or self.login_entry.get() == ''
                    ' ' in self.email_entry.get() or ' ' in self.entry_password.get() or ' ' in self.login_entry.get()):

                self.email_error_label.configure(text="Логин, пароль и email обязательные поля для заполнения",
                                                 font=self.default_font_set(size=20),
                                                 text_color='#da314a',
                                                 anchor='nw'
                                                 )

            elif not validate_email(self.email_entry.get()):
                self.email_error_label.configure(text="Введён несуществующий email",
                                                 font=self.default_font_set(size=20),
                                                 text_color='#da314a',
                                                 anchor='nw'
                                                 )
            else:
                self.email_error_label.configure(text="",
                                                 bg_color=self.bg_cl_aureg
                                                 )
                connection = sqlite3.connect('database.db')
                cursor = connection.cursor()
                # Создаем таблицу Users
                cursor.execute("""
                                            CREATE TABLE IF NOT EXISTS Users (
                                            login TEXT,
                                            password TEXT,
                                            email TEXT,
                                            gender TEXT,
                                            age INT,
                                            color_mode BOOL
                                            );
                                            """)
                t_bool = True
                db_list = tuple(cursor.execute('SELECT * FROM Users').fetchall())
                for i in range(len(db_list)):
                    if self.login_entry.get() in db_list[i] or self.email_entry.get() in db_list[i]:
                        t_bool = False

                if self.entry_age.get() != '':
                    age = int(self.entry_age.get())
                else:
                    age = ''

                if t_bool:
                    cursor.execute('INSERT INTO Users (login, password, email, gender, age, color_mode) '
                                   'VALUES (?, ?, ?, ?, ?, ?)',
                                   (self.login_entry.get(), self.entry_password.get(),
                                    self.email_entry.get(), self.gender_var.get(), age, True))

                    messagebox.showinfo("УспЭх", "Аккаунт зарегестрирован")

                    connection.commit()
                    connection.close()

                    connection2 = sqlite3.connect('database.db')

                    cursor = connection2.cursor()
                    # Создаем таблицу Users
                    cursor.execute("""
                                                    CREATE TABLE IF NOT EXISTS leaderBoard (
                                                    login TEXT,
                                                    win_count INT,
                                                    draw_count INT,
                                                    lost_count INT,
                                                    cobble_player INT,
                                                    scissors_player INT,
                                                    papper_player INT,
                                                    cobble_bot INT,
                                                    scissors_bot INT,
                                                    papper_bot INT
                                                    papper_bot INT
                                                    );
                                                    """)

                    cursor.execute('INSERT INTO leaderBoard (login, win_count, draw_count, lost_count, '
                                   'cobble_player, scissors_player, papper_player,'
                                   'cobble_bot, scissors_bot, papper_bot) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                                   (self.login_entry.get(), 0, 0, 0, 0, 0, 0, 0, 0, 0))
                    connection2.commit()
                    connection2.close()
                    self.new_window(Autorisation, self)

                else:
                    self.age_error_label.configure(text="Недопустимый год рождения",
                                                   font=self.default_font_set(size=20),
                                                   text_color='#da314a',
                                                   anchor='nw'
                                                   )
                    # Сохраняем изменения и закрываем соединение

        except (TypeError, ValueError):
            self.age_error_label.configure(text="Недопустимое значение для года рождения",
                                           font=self.default_font_set(size=20),
                                           text_color='#da314a',
                                           anchor='nw'
                                           )


# Класс для приветственного окна и меню
class Welcome(Parent):
    def __init__(self, parent):
        Parent.__init__(self, parent)
        self.root = parent
        self.interface()

    # Метод для интерфейса
    def interface(self):
        # Задание заднего цвета окна
        self.config(bg=self.bg_cl_aureg)
        # Запрет изменения размера окна
        self.resizable(False, False)
        # Задание размеров окну
        self.geometry("1050x550")

        # Заголовок
        CTkLabel(
            self,
            text="Камень, ножницы, бумага", width=1050, height=60,
            text_color=Parent.font_color,
            font=Parent.default_font_set(size=35),
            bg_color=Parent.bg_cl
        ).grid(row=0, column=0, columnspan=3, pady=10, sticky="NSEW")

        # Кнопки
        buttons = [
            ("Играть", lambda: self.new_window(RockPaperScissorsGame, self)),
            ("Поменять тему", lambda: self.change_theme()),
            ("Выйти из аккаунта", lambda: self.new_window(StartScreen, self)),
            ("Выйти на рабочий стол", self.destroy)
        ]

        # Создание кнопок для приветственного экрана
        for i, (text, command) in enumerate(buttons, start=1):
            self.create_button(
                self,
                text=text,
                hover_color="#55a19d",
                fg_color=Parent.bg_cl,
                bg_color=Parent.bg_cl_aureg,
                text_color=Parent.font_color,
                corner_radius=10,
                font=Parent.default_font_set(size=30),
                width=10,
                height=70,
                command=command,
                row=i,
                column=0, padx=20, pady=5, sticky="EW"
            )

        # Таблица лидеров
        CTkLabel(
            self,
            text="Таблица лидеров",
            font=Parent.default_font_set(size=30),
            text_color=Parent.font_color,
            bg_color=Parent.bg_cl,
            height=60,
            width=100,
        ).grid(row=5, column=1, columnspan=1, pady=10, sticky="NSEW")

        # Показ текущего пользователя
        CTkLabel(
            self,
            text="Пользователь: " + Parent.login,
            font=Parent.default_font_set(size=30),
            text_color=Parent.font_color,
            bg_color=Parent.bg_cl
        ).grid(row=5, column=0, columnspan=1, pady=10, sticky="NSEW")

        # Стили для Treeview
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Treeview",
                        background=Parent.bg_cl,
                        foreground=Parent.fg_cl,
                        rowheight=40,
                        fieldbackground=Parent.bg_cl,
                        text_color=Parent.font_color,
                        font=Parent.default_font_set(size=23))
        style.configure("Treeview.Heading",
                        background=Parent.bg_cl,
                        foreground=Parent.fg_cl,
                        text_color=Parent.font_color,
                        font=Parent.default_font_set(size=27))
        style.map("Treeview",
                  background=[("selected", "#55a19d")],
                  foreground=[("selected", Parent.fg_cl)])

        # Таблица лидеров
        tree = ttk.Treeview(self, columns=("Name", "Win amount", "K/D", "Game played"), show="headings", height=8)
        tree.grid(row=1, column=1, rowspan=4, padx=10, pady=10, sticky="NSEW")
        tree.heading("Name", text="Имя")
        tree.heading("Win amount", text="Побед")
        tree.heading("K/D", text="K/D")
        tree.heading("Game played", text="Сыграно")
        tree.column("Name", width=150, anchor="center")
        tree.column("Win amount", width=150, anchor="center")
        tree.column("K/D", width=150, anchor="center")
        tree.column("Game played", width=150, anchor="center")

        connection2 = sqlite3.connect('database.db')
        cursor = connection2.cursor()

        sqlite_select_query = """SELECT * from leaderBoard"""
        db_list = tuple(cursor.execute(sqlite_select_query, ).fetchall())

        connection2.commit()
        connection2.close()

        # Заполнение таблицы
        data = []
        print(db_list)
        for i in range(len(db_list)):
            try:
                data.append((db_list[i][0], db_list[i][1],
                             round(db_list[i][1] + db_list[i][2] +
                                   db_list[i][3] / db_list[i][1], 2),
                             db_list[i][1] + db_list[i][2] + db_list[i][3]))
                # Проверка на отсутствия побед
            except ZeroDivisionError:
                data.append((db_list[i][0], db_list[i][1], 0,
                             db_list[i][1] + db_list[i][2] + db_list[i][3]))

        for item in data:
            tree.insert("", "end", values=item)

        # Добавление функциональности сортировки
        for col in ("Name", "Win amount", "K/D", "Game played"):
            tree.heading(col, command=lambda _col=col: self.treeview_sort_column(tree, _col, False))

        # Сортировка таблицы
    def treeview_sort_column(self, treeview, col, reverse):
        data = [(treeview.set(child, col), child) for child in treeview.get_children('')]

        # Определение типа данных для сортировки
        try:
            # Если данные могут быть преобразованы в числа
            data.sort(key=lambda t: float(t[0]) if t[0] else 0, reverse=reverse)
        except ValueError:
            # Если данные являются строками
            data.sort(key=lambda t: t[0], reverse=reverse)

        # Перестановка элементов Treeview в отсортированном порядке
        for index, (_, child) in enumerate(data):
            treeview.move(child, '', index)

        # Изменить порядок сортировки при следующем клике
        treeview.heading(col, command=lambda: self.treeview_sort_column(treeview, col, not reverse))

    def change_theme(self):
        if self.mode == "dark":
            set_appearance_mode("light")
            Parent.mode = "light"
            Parent.bg_cl = '#21A3C7'
            Parent.bg_cl_aureg = 'white'
            Parent.fg_cl = 'white'
            Parent.log_cl = '#3471ac'
            Parent.font_color = 'white'
            Parent.new_window(Welcome, self)
        else:
            set_appearance_mode("dark")
            Parent.bg_cl = "#141a2a"  # Переменная хранящяя цвет заднего фона
            Parent.fg_cl = 'white'  # Переменная хранящяя цвет переднего фона (шрифта)
            Parent.log_cl = '#1C202B'  # Переменная хранящяя цвет заднего фона для загаловков
            Parent.bg_cl_aureg = '#212633'  # Переменная хранящяя цвет заднего фона для некоторых окон
            Parent.font_color = 'white'
            set_appearance_mode("dark")  # Modes: system (default), light, dark
            set_default_color_theme("dark-blue")  # Themes: blue (default), dark-blue, green
            Parent.mode = "dark"
            Parent.new_window(Welcome, self)
            # Clear text box


# Запуск стартового окна
menu = StartScreen(None)
menu.geometry("950x740")
menu.minsize(200, 200)
menu.mainloop()
